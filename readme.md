## Middle Golang Developer

### Задача: Реализация сервиса Smart Exchange (агрегатор лучшей цены) на Go + Clean Architecture.

### Основные требования:

1. Сценарий обмена:
    - Пользователь указывает сумму и пару валют (например, 100 RUB → USD).
    - Сервис запрашивает курсы у всех подключенных внешних обменников (банки, частники и т.д.).
    - _Фильтрация обменников_:
        - Те, которые поддерживают нужную валютную пару.
        - Примечание: Резервы внешних обменников нам неизвестны и не контролируются.
    - Сервис выбирает **лучший курс** из доступных, добавляет свою комиссию (например, 1%) и предлагает пользователю
      итоговый курс.
    - _Проверка собственных резервов_:
        - Если у сервиса достаточно резервов для сделки: резервы сервиса обновляются (списание одной валюты, зачисление
          другой).
    - Если резервов **не хватает**:
        - Сервис должен самостоятельно обменять недостающую сумму через внешние обменники (например, купить USD за свои
          RUB), а затем провести сделку с пользователем.
    - Фиксация сделки в истории.

2. Технические условия:
    - Время выполнения всего цикла обмена ≤ 2 секунд (включая возможный обмен через внешние сервисы для пополнения
      резервов).
    - Обменники могут быть недоступны, отвечать с ошибками или задержками.
    - Резервы сервиса задаются при старте (например, 1 000 000 RUB, 10 000 USD) и хранятся внутри системы.
    - Каждая сделка записывается с деталями: сумма, курс, комиссия, timestamp.

3. Архитектура:
    - Clean Architecture с четким разделением слоев.
    - Возможность легко добавлять новые обменники через интерфейсы (например, ExchangeProvider).
    - Конфигурация через файл (например: список обменников, их начальные резервы, доступные валютные пары и курсы,
      собственная комиссия).
    - Доменные сущности и структура БД остаются на ваше усмотрение.

### Улучшения (опционально, но будет плюсом):

1. Кросс-обмен (роутинг):

    - Если прямой обмен недоступен или невыгоден, реализовать обмен через цепочку валют (например, RUB → EUR → USD).
    - Учесть комиссии на каждом этапе (влияет на финальный курс для пользователя) и общее время выполнения.

2. Отчётность:
    - Прибыли/убытков (PNL) за день/неделю/месяц.
    - Истории сделок.

3. Резервирование средств:
    - Реализовать механизм "блокировки" резервов на время обработки сделки, чтобы избежать конфликтов при параллельных
      запросах.

### Что ожидается в решении:

- Код на Go с тестами (unit, интеграционные).
- Документация:
    - Как запустить проект.
    - Примеры запросов к API.
    - Описание архитектуры и ключевых решений (например, выбор алгоритма для кросс-обмена).
- Dockerfile (желательно).

### Критерии оценки:

- Качество кода:
    - Соблюдение принципов Clean Architecture, SOLID.
    - Обработка ошибок, тесты, логирование.

- Производительность:
    - Оптимальное использование горутин/channels для параллельных запросов к обменникам.
    - Учет таймаутов и отмены операций при превышении лимита в 2 секунды.

- Безопасность резервов:
    - Отсутствие race condition при работе с балансами.

- Масштабируемость:
    - Легко добавить новый обменник или валюту.

### Советы:

- Пожалуйста, **не используйте gpt**, во-первых: это видно, во-вторых, нам с вами в любом случае дальше работать, лучше
  потратьте время и напишите свою реализацию.
- Используйте моки для внешних обменников, чтобы не зависеть от реальных API.
- Подумайте, как минимизировать потери при вынужденном обмене резервов (например, выбрать обменник с лучшим курсом для
  пополнения).
- Уделите внимание атомарности операций с резервами.
- Пользователь в рамках данного функционала не учитывается, просто передаем/сохраняем user id
